"""
Global SSE Manager for Gumbo Suggestion System

This module provides a centralized SSE (Server-Sent Events) management system
that bridges the gap between the Gumbo engine and the controller SSE endpoint.

The GlobalSSEManager ensures that suggestions generated by the Gumbo engine
are properly broadcast to all connected frontend clients via the controller's
SSE endpoint.
"""

import asyncio
import json
import logging
from typing import Dict, Any
from datetime import datetime, timezone

logger = logging.getLogger(__name__)


class SSEConnection:
    """Represents a single SSE connection with its metadata."""
    
    def __init__(self, connection_id: str, queue: asyncio.Queue):
        self.connection_id = connection_id
        self.queue = queue
        self.connected_at = datetime.now(timezone.utc)
        self.events_sent = 0
        self.last_activity = datetime.now(timezone.utc)


class GlobalSSEManager:
    """
    Global SSE manager that coordinates event broadcasting between
    the Gumbo engine and frontend clients.
    
    This manager maintains a registry of active SSE connections and
    provides methods for broadcasting events to all connected clients.
    """
    
    def __init__(self):
        self._connections: Dict[str, SSEConnection] = {}
        self._lock = asyncio.Lock()
        self._total_events_sent = 0
        self._total_connections_created = 0
    
    async def register_connection(self, connection_id: str, queue: asyncio.Queue):
        """
        Register a new SSE connection.
        
        Args:
            connection_id: Unique identifier for the connection
            queue: Asyncio queue for sending events to this connection
        """
        async with self._lock:
            self._connections[connection_id] = SSEConnection(connection_id, queue)
            self._total_connections_created += 1
            logger.info(f"SSE connection registered: {connection_id} (total: {len(self._connections)})")
    
    async def unregister_connection(self, connection_id: str):
        """
        Unregister an SSE connection.
        
        Args:
            connection_id: Unique identifier for the connection to remove
        """
        async with self._lock:
            if connection_id in self._connections:
                connection = self._connections[connection_id]
                del self._connections[connection_id]
                logger.info(f"SSE connection unregistered: {connection_id} "
                          f"(sent {connection.events_sent} events, remaining: {len(self._connections)})")
            else:
                logger.warning(f"Attempted to unregister unknown connection: {connection_id}")
    
    async def broadcast_event(self, event_type: str, data: Dict[str, Any]):
        """
        Broadcast an event to all connected SSE clients.
        
        Args:
            event_type: Type of event (e.g., 'suggestion_batch', 'heartbeat', 'error')
            data: Event data dictionary
        """
        async with self._lock:
            if not self._connections:
                logger.debug(f"No SSE connections to broadcast {event_type} event to")
                return
            
            # Prepare event data in SSE format
            event_data = {
                "event": event_type,
                "data": json.dumps(data, default=str)
            }
            
            # Track failed connections for cleanup
            failed_connections = []
            successful_broadcasts = 0
            
            # Broadcast to all connections
            for connection_id, connection in self._connections.items():
                try:
                    # Put event in connection's queue (non-blocking)
                    await connection.queue.put(event_data)
                    
                    # Update connection stats
                    connection.events_sent += 1
                    connection.last_activity = datetime.now(timezone.utc)
                    successful_broadcasts += 1
                    
                    logger.debug(f"Broadcasted {event_type} to {connection_id}")
                    
                except Exception as e:
                    logger.warning(f"Failed to broadcast {event_type} to {connection_id}: {e}")
                    failed_connections.append(connection_id)
            
            # Clean up failed connections
            for connection_id in failed_connections:
                if connection_id in self._connections:
                    del self._connections[connection_id]
            
            # Update global stats
            self._total_events_sent += successful_broadcasts
            
            logger.info(f"Broadcasted {event_type} event to {successful_broadcasts} connections "
                       f"({len(failed_connections)} failed)")
    
    def get_connection_count(self) -> int:
        """Get the current number of active connections."""
        return len(self._connections)
    
    def get_stats(self) -> Dict[str, Any]:
        """
        Get comprehensive statistics about the SSE manager.
        
        Returns:
            Dictionary containing connection and event statistics
        """
        return {
            "active_connections": len(self._connections),
            "total_connections_created": self._total_connections_created,
            "total_events_sent": self._total_events_sent,
            "connection_details": [
                {
                    "connection_id": conn.connection_id,
                    "connected_at": conn.connected_at.isoformat(),
                    "events_sent": conn.events_sent,
                    "last_activity": conn.last_activity.isoformat()
                }
                for conn in self._connections.values()
            ]
        }
    
    async def cleanup_stale_connections(self, max_idle_minutes: int = 30):
        """
        Clean up connections that have been idle for too long.
        
        Args:
            max_idle_minutes: Maximum idle time before connection is considered stale
        """
        async with self._lock:
            if not self._connections:
                return
            
            now = datetime.now(timezone.utc)
            stale_connections = []
            
            for connection_id, connection in self._connections.items():
                idle_time = (now - connection.last_activity).total_seconds() / 60
                if idle_time > max_idle_minutes:
                    stale_connections.append(connection_id)
            
            for connection_id in stale_connections:
                del self._connections[connection_id]
                logger.info(f"Cleaned up stale SSE connection: {connection_id}")
            
            if stale_connections:
                logger.info(f"Cleaned up {len(stale_connections)} stale connections")


# Global instance - singleton pattern
_global_sse_manager = None


def get_sse_manager() -> GlobalSSEManager:
    """
    Get the global SSE manager instance.
    
    Returns:
        GlobalSSEManager: The singleton SSE manager instance
    """
    global _global_sse_manager
    if _global_sse_manager is None:
        _global_sse_manager = GlobalSSEManager()
        logger.info("Global SSE manager initialized")
    return _global_sse_manager


async def cleanup_sse_manager():
    """Clean up the global SSE manager (for shutdown)."""
    global _global_sse_manager
    if _global_sse_manager is not None:
        # Clean up any remaining connections
        await _global_sse_manager.cleanup_stale_connections(max_idle_minutes=0)
        _global_sse_manager = None
        logger.info("Global SSE manager cleaned up")
